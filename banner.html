<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated GitHub Banner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            display: block;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="bannerCanvas" width="1080" height="360"></canvas>

    <script>
        const canvas = document.getElementById('bannerCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const config = {
            width: 1080,
            height: 360,
            centerX: 540,
            centerY: 180,
            stars: 50,
            snakeSegments: 30,
            snakeRadius: 80
        };

        // Star particles
        class Star {
            constructor() {
                this.x = Math.random() * config.width;
                this.y = Math.random() * config.height;
                this.size = Math.random() * 1.5 + 0.5;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinkleOffset = Math.random() * Math.PI * 2;
            }

            update(time) {
                this.opacity = 0.3 + Math.sin(time * this.twinkleSpeed + this.twinkleOffset) * 0.2;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Snake particle system
        class Snake {
            constructor() {
                this.segments = [];
                this.time = 0;
                this.init();
            }

            init() {
                for (let i = 0; i < config.snakeSegments; i++) {
                    this.segments.push({
                        x: 0,
                        y: 0,
                        opacity: 1 - (i / config.snakeSegments) * 0.7,
                        size: 8 - (i / config.snakeSegments) * 4
                    });
                }
            }

            update(time) {
                this.time = time;
                const baseRadius = config.snakeRadius;
                const speed = 0.0008;
                const waveAmplitude = 25;
                
                // Create smooth slithering motion around the text
                for (let i = 0; i < this.segments.length; i++) {
                    const t = (time * speed) - (i * 0.04);
                    const angle = t * Math.PI * 2;
                    
                    // Varying radius for organic movement
                    const radiusVariation = Math.sin(t * Math.PI * 3) * waveAmplitude;
                    const radius = baseRadius + radiusVariation;
                    
                    // Add wave motion for slithering effect
                    const wave = Math.sin(t * Math.PI * 6 + i * 0.3) * 12;
                    const perpAngle = angle + Math.PI / 2;
                    
                    this.segments[i].x = config.centerX + Math.cos(angle) * radius + Math.cos(perpAngle) * wave;
                    this.segments[i].y = config.centerY + Math.sin(angle) * radius + Math.sin(perpAngle) * wave;
                    
                    // Fade tail effect
                    const fadeStart = 0.3;
                    const fadeProgress = Math.max(0, (i / this.segments.length - fadeStart) / (1 - fadeStart));
                    this.segments[i].opacity = 1 - fadeProgress * 0.7;
                    this.segments[i].size = 8 - (i / this.segments.length) * 4;
                }
            }

            draw() {
                // Draw connecting lines
                ctx.save();
                for (let i = 0; i < this.segments.length - 1; i++) {
                    const current = this.segments[i];
                    const next = this.segments[i + 1];
                    
                    const gradient = ctx.createLinearGradient(
                        current.x, current.y,
                        next.x, next.y
                    );
                    gradient.addColorStop(0, `rgba(139, 92, 246, ${current.opacity})`);
                    gradient.addColorStop(1, `rgba(139, 92, 246, ${next.opacity})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = current.opacity;
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.stroke();
                }
                ctx.restore();

                // Draw particles
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    ctx.save();
                    ctx.globalAlpha = seg.opacity;
                    
                    // Outer glow
                    const glowGradient = ctx.createRadialGradient(
                        seg.x, seg.y, 0,
                        seg.x, seg.y, seg.size * 2
                    );
                    glowGradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
                    glowGradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.4)');
                    glowGradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(seg.x, seg.y, seg.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core particle
                    ctx.fillStyle = '#8B5CF6';
                    ctx.beginPath();
                    ctx.arc(seg.x, seg.y, seg.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }

        // Initialize
        const stars = [];
        for (let i = 0; i < config.stars; i++) {
            stars.push(new Star());
        }

        const snake = new Snake();
        let animationTime = 0;

        // Background gradient with subtle animation
        function drawBackground(time) {
            // Animated radial gradients for ambient lighting
            const gradient1 = ctx.createRadialGradient(
                config.centerX - 200, config.centerY - 100, 0,
                config.centerX - 200, config.centerY - 100, 600
            );
            gradient1.addColorStop(0, 'rgba(26, 10, 46, 0.6)');
            gradient1.addColorStop(1, 'rgba(10, 10, 10, 0)');
            
            const gradient2 = ctx.createRadialGradient(
                config.centerX + 200, config.centerY + 100, 0,
                config.centerX + 200, config.centerY + 100, 600
            );
            gradient2.addColorStop(0, 'rgba(26, 10, 46, 0.4)');
            gradient2.addColorStop(1, 'rgba(10, 10, 10, 0)');
            
            // Base gradient
            const baseGradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            baseGradient.addColorStop(0, '#0a0a0a');
            baseGradient.addColorStop(0.3, '#0f0a1a');
            baseGradient.addColorStop(0.5, '#1a0a2e');
            baseGradient.addColorStop(0.7, '#0f0a1a');
            baseGradient.addColorStop(1, '#0a0a0a');
            
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // Add ambient lighting
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, config.width, config.height);
            
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, 0, config.width, config.height);
        }

        // Abstract tech shapes
        function drawTechShapes(time) {
            ctx.save();
            ctx.globalAlpha = 0.08;
            ctx.strokeStyle = '#6366F1';
            ctx.lineWidth = 0.5;
            
            // Subtle animated grid pattern
            const gridSize = 40;
            const offset = (time * 0.01) % gridSize;
            
            for (let i = -1; i < config.width / gridSize + 1; i++) {
                const x = i * gridSize + offset;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, config.height);
                ctx.stroke();
            }
            
            for (let i = -1; i < config.height / gridSize + 1; i++) {
                const y = i * gridSize + offset;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(config.width, y);
                ctx.stroke();
            }
            
            // Subtle corner accents
            ctx.globalAlpha = 0.15;
            const cornerSize = 100;
            const pulse = Math.sin(time * 0.5) * 0.5 + 0.5;
            
            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(cornerSize * pulse, 0);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, cornerSize * pulse);
            ctx.stroke();
            
            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(config.width, 0);
            ctx.lineTo(config.width - cornerSize * pulse, 0);
            ctx.moveTo(config.width, 0);
            ctx.lineTo(config.width, cornerSize * pulse);
            ctx.stroke();
            
            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(0, config.height);
            ctx.lineTo(cornerSize * pulse, config.height);
            ctx.moveTo(0, config.height);
            ctx.lineTo(0, config.height - cornerSize * pulse);
            ctx.stroke();
            
            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(config.width, config.height);
            ctx.lineTo(config.width - cornerSize * pulse, config.height);
            ctx.moveTo(config.width, config.height);
            ctx.lineTo(config.width, config.height - cornerSize * pulse);
            ctx.stroke();
            
            ctx.restore();
        }

        // Neon "Hello World" text with pulsing glow
        function drawText(time) {
            const text = "Hello World";
            ctx.save();
            
            // Pulsing glow effect
            const pulse = Math.sin(time * 2) * 0.1 + 0.9;
            
            // Multiple glow layers for depth
            for (let i = 8; i > 0; i--) {
                ctx.shadowBlur = i * 6 * pulse;
                ctx.shadowColor = `rgba(139, 92, 246, ${0.15 * i * pulse})`;
                ctx.fillStyle = `rgba(139, 92, 246, ${0.05 * i})`;
                ctx.font = `bold ${64 - i * 2}px 'Arial', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, config.centerX, config.centerY);
            }
            
            // Main text with strong glow
            ctx.shadowBlur = 25 * pulse;
            ctx.shadowColor = 'rgba(139, 92, 246, 0.9)';
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 64px "Arial", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, config.centerX, config.centerY);
            
            // Inner bright glow
            ctx.shadowBlur = 35 * pulse;
            ctx.shadowColor = 'rgba(139, 92, 246, 1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText(text, config.centerX, config.centerY);
            
            ctx.restore();
        }

        // Animation loop
        function animate() {
            animationTime += 0.016; // ~60fps
            
            // Clear and draw background
            drawBackground(animationTime);
            
            // Draw tech shapes
            drawTechShapes(animationTime);
            
            // Update and draw stars
            stars.forEach(star => {
                star.update(animationTime);
                star.draw();
            });
            
            // Update and draw snake
            snake.update(animationTime);
            snake.draw();
            
            // Draw text (on top)
            drawText(animationTime);
            
            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>

